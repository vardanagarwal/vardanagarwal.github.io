<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>data_handling.coco_assistant.coco_assistant API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>data_handling.coco_assistant.coco_assistant</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
import ast
import json
import logging
import os
import random
import sys
import shutil

from pathlib import Path
from pycocotools.coco import COCO
from tqdm import tqdm

from data_handling.coco_assistant import coco_stats as stats
from data_handling.coco_assistant import coco_visualiser as cocovis
from data_handling.coco_assistant import utils

logging.basicConfig(level=logging.ERROR)
logging.getLogger().setLevel(logging.WARNING)
logging.getLogger(&#34;parso.python.diff&#34;).disabled = True

&#34;&#34;&#34;
Expected Directory Structure

.
├── images
│   ├── train
│   ├── val
|   ├── test
|
├── annotations
│   ├── train.json
│   ├── val.json
│   ├── test.json


&#34;&#34;&#34;

class COCO_Assistant:
    def __init__(self, img_dir, ann_dir):
        &#34;&#34;&#34;
        :param img_dir (str): path to images folder.
        :param ann_dir (str): path to annotations folder.
        &#34;&#34;&#34;
        self.img_dir = Path(img_dir)
        self.ann_dir = Path(ann_dir)

        # Parent dir should be the same
        if self.ann_dir.parents[0] != self.img_dir.parents[0]:
            raise AssertionError(&#34;Directory not in expected format&#34;)
        self.res_dir = self.ann_dir.parents[0]

        # Create Results Directory
        if not self.res_dir.exists():
            self.res_dir.mkdir()

        self.imgfolders = sorted(
            [i for i in self.img_dir.iterdir() if i.is_dir() and not i.name.startswith(&#34;.&#34;)]
        )
        imnames = [n.stem for n in self.imgfolders]

        self.jsonfiles = sorted([j for j in self.ann_dir.iterdir() if j.suffix == &#34;.json&#34;])
        jnames = [n.stem for n in self.jsonfiles]

        if imnames != jnames:
            raise AssertionError(&#34;Image dir and corresponding json file must have the same name&#34;)

        self.names = imnames

        # TODO: Add check for confirming these folders only contain .jpg and .json respectively
        logging.debug(&#34;Number of image folders = %s&#34;, len(self.imgfolders))
        logging.debug(&#34;Number of annotation files = %s&#34;, len(self.jsonfiles))

        if not self.jsonfiles:
            raise AssertionError(&#34;Annotation files not passed&#34;)
        if not self.imgfolders:
            raise AssertionError(&#34;Image folders not passed&#34;)

        self.annfiles = [COCO(i) for i in self.jsonfiles]
        self.anndict = dict(zip(self.jsonfiles, self.annfiles))

        self.ann_anchors = []

    def merge(self, output_folder=&#34;merged&#34;, merge_images=True, duplicate_frame=True):
        &#34;&#34;&#34;
        Function for merging multiple coco datasets
        &#34;&#34;&#34;
        self.resim_dir = Path(output_folder) / &#34;images&#34;
        self.resann_dir = Path(output_folder) / &#34;annotations&#34;

        utils.make_clean(self.resim_dir)
        utils.make_clean(self.resann_dir)

        duplicate_image_names = {}
        for i in range(1, len(self.imgfolders)):
            duplicate_image_names[i] = {}

        if merge_images:
            print(&#34;Merging image dirs&#34;)
            im_dirs = self.imgfolders
            imext = [&#34;.png&#34;, &#34;.jpg&#34;, &#34;.jpeg&#34;]

            logging.debug(&#34;Merging Image Dirs...&#34;)

            for ind, imdir in enumerate(tqdm(im_dirs)):
                ims = [i for i in imdir.iterdir() if i.suffix.lower() in imext]
                for im in ims:
                    if duplicate_frame:
                        if os.path.isfile(self.resim_dir / im.name):
                            im_name = im_name_copy = str(im.name)
                            pos = im_name.rfind(&#39;.&#39;)
                            for i in range(500):
                                if not os.path.isfile(os.path.join(self.resim_dir, im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:])):
                                    im_name = im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:]
                                    break
                            
                            duplicate_image_names[ind][im_name_copy] = im_name
                            im_name = Path(im_name)
                        else:
                            im_name = im.name
                    else:
                        im_name = im.name

                    shutil.copyfile(im, self.resim_dir / im_name)

        else:
            logging.debug(&#34;Not merging Image Dirs...&#34;)

        cann = {&#34;images&#34;: [], &#34;annotations&#34;: [], &#34;info&#34;: None, &#34;licenses&#34;: None, &#34;categories&#34;: None}

        logging.debug(&#34;Merging Annotations...&#34;)

        dst_ann = self.resann_dir / &#34;merged.json&#34;

        print(&#34;Merging annotations&#34;)
        for j in tqdm(self.jsonfiles):
            with open(j) as a:
                cj = json.load(a)

            ind = self.jsonfiles.index(j)
            # Check if this is the 1st annotation.
            # If it is, continue else modify current annotation
            if ind == 0:
                cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj[&#34;images&#34;]
                cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
                if &#34;info&#34; in list(cj.keys()):
                    cann[&#34;info&#34;] = cj[&#34;info&#34;]
                if &#34;licenses&#34; in list(cj.keys()):
                    cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]
                cann[&#34;categories&#34;] = sorted(cj[&#34;categories&#34;], key=lambda i: i[&#34;id&#34;])

                last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
                last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

                # If last imid or last_annid is a str, convert it to int
                if isinstance(last_imid, str) or isinstance(last_annid, str):
                    logging.debug(&#34;String Ids detected. Converting to int&#34;)
                    id_dict = {}
                    # Change image id in images field
                    for i, im in enumerate(cann[&#34;images&#34;]):
                        id_dict[im[&#34;id&#34;]] = i
                        im[&#34;id&#34;] = i

                    # Change annotation id &amp; image id in annotations field
                    for i, im in enumerate(cann[&#34;annotations&#34;]):
                        im[&#34;id&#34;] = i
                        if isinstance(last_imid, str):
                            im[&#34;image_id&#34;] = id_dict[im[&#34;image_id&#34;]]

                last_imid = max([im[&#34;id&#34;] for im in cann[&#34;images&#34;]])
                last_annid = max([ann[&#34;id&#34;] for ann in cann[&#34;annotations&#34;]])

            else:

                id_dict = {}
                # Change image id in images field
                for i, im in enumerate(cj[&#34;images&#34;]):
                    id_dict[im[&#34;id&#34;]] = last_imid + i + 1
                    im[&#34;id&#34;] = last_imid + i + 1
                    if duplicate_frame:
                        if im[&#34;file_name&#34;] in duplicate_image_names[ind]:
                            im[&#34;file_name&#34;] = duplicate_image_names[ind][im[&#34;file_name&#34;]]

                # Change annotation and image ids in annotations field
                for i, ann in enumerate(cj[&#34;annotations&#34;]):
                    ann[&#34;id&#34;] = last_annid + i + 1
                    ann[&#34;image_id&#34;] = id_dict[ann[&#34;image_id&#34;]]

                # Remap categories
                cmapper = utils.CatRemapper(cann[&#34;categories&#34;], cj[&#34;categories&#34;])
                cann[&#34;categories&#34;], cj[&#34;annotations&#34;] = cmapper.remap(cj[&#34;annotations&#34;])

                cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj[&#34;images&#34;]
                cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
                if &#34;info&#34; in list(cj.keys()):
                    cann[&#34;info&#34;] = cj[&#34;info&#34;]
                if &#34;licenses&#34; in list(cj.keys()):
                    cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]

                last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
                last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

        with open(dst_ann, &#34;w&#34;) as aw:
            json.dump(cann, aw)

    def remove_cat(self, interactive=True, remove_empty_frames=True, jc=None, rcats=None):
        &#34;&#34;&#34;
        Function for removing certain categories.
        In interactive mode, you can input the json and the categories
        to be removed (as a list, see README for example)
        In non-interactive mode, you manually pass in json filename and
        categories to be removed. Note that jc and
        rcats cannot be None if run with interactive=False.

        :param interactive: Run category removal in interactive mode
        :param remove_empty_frames: Remove frames which do not have annotations after removing category
        :param jc: Json choice
        :param rcats: Categories to be removed
        &#34;&#34;&#34;
        resrm_dir = self.res_dir / &#34;removal&#34;
        utils.make_clean(resrm_dir)
        # jnames == imnames -&gt; No extension

        if interactive:
            print(self.names)
            print(&#34;Choose directory index (1:first, 2: second ..)&#34;)

            json_choice = input()
            try:
                json_choice = int(json_choice) - 1
            except ValueError:
                sys.exit(&#34;Please specify an index&#34;)

            if json_choice &gt; len(self.names):
                raise AssertionError(&#34;Index exceeds number of datasets&#34;)
            ann = self.annfiles[json_choice]
            json_name = self.jsonfiles[json_choice].name
            self.jc = json_name  # hack

            print(&#34;\nCategories present:&#34;)
            cats = [i[&#34;name&#34;] for i in ann.cats.values()]
            print(cats)

            self.rcats = []
            print(&#34;\nEnter categories you wish to remove as a list:&#34;)
            x = input()
            x = ast.literal_eval(x)
            if isinstance(x, list) is False:
                raise AssertionError(&#34;Input must be a list of categories to be removed&#34;)
            if all(elem in cats for elem in x):
                self.rcats = x
            else:
                print(&#34;Incorrect entry.&#34;)

        else:
            if jc is None or rcats is None:
                raise AssertionError(
                    &#34;Both json choice and rcats need to be provided in non-interactive mode&#34;
                )
            # If passed, json_choice needs to be full path
            json_choice = Path(jc)  # Full path
            json_name = json_choice.name  # abc.json
            self.jc = json_name  # hack
            ann = self.anndict[Path(json_choice)]
            self.rcats = rcats

            img_folder = self.imgfolders[self.jsonfiles.index(json_choice)]

        print(&#34;Removing specified categories...&#34;)

        # Gives you a list of category ids of the categories to be removed
        catids_remove = ann.getCatIds(catNms=self.rcats)
        # Gives you a list of ids of annotations that contain those categories
        annids_remove = ann.getAnnIds(catIds=catids_remove)

        # Get keep category ids
        catids_keep = list(set(ann.getCatIds()) - set(catids_remove))
        # Get keep annotation ids
        annids_keep = list(set(ann.getAnnIds()) - set(annids_remove))

        with open(self.ann_dir / json_name) as it:
            x = json.load(it)

        del x[&#34;categories&#34;]
        x[&#34;categories&#34;] = ann.loadCats(catids_keep)
        del x[&#34;annotations&#34;]
        x[&#34;annotations&#34;] = ann.loadAnns(annids_keep)

        if remove_empty_frames:
            image_ids = []
            image_file_names = []
            for annotation in x[&#34;annotations&#34;]:
                image_ids.append(annotation[&#34;image_id&#34;])
            image_ids = list(set(image_ids))
            remove_image_ids = ann.getImgIds(catIds=catids_remove)
            all_image_ids = ann.getImgIds()
            
            del x[&#34;images&#34;]
            x[&#34;images&#34;] = ann.loadImgs(list(set(image_ids).union(set(all_image_ids) - set(remove_image_ids))))

            for image in x[&#34;images&#34;]:
                image_file_names.append(image[&#34;file_name&#34;])
            
            # img_folder = json_name
            all_image_names = os.listdir(img_folder)
            for single_image_name in all_image_names:
                if single_image_name not in image_file_names:
                    os.remove(img_folder / Path(single_image_name))
        

        with open(resrm_dir / json_name, &#34;w&#34;) as oa:
            json.dump(x, oa)

    def ann_stats(self, stat, arearng, show_count=False, save=False):
        &#34;&#34;&#34;
        Function for displaying statistics.
        &#34;&#34;&#34;
        if stat == &#34;area&#34;:
            stats.pi_area_split(self.annfiles, self.names, areaRng=arearng, save=save)
        elif stat == &#34;cat&#34;:
            stats.cat_count(self.annfiles, self.names, show_count=show_count, save=save)

    def anchors(self, n, fmt=None, recompute=False):
        &#34;&#34;&#34;
        Function for generating top &#39;n&#39; anchors

        :param n: Number of anchors
        :param fmt: Format of anchors [&#39;square&#39;, None]
        :param recompute: Rerun k-means and recompute anchors
        &#34;&#34;&#34;
        if recompute or not self.ann_anchors:
            print(&#34;Calculating anchors...&#34;)
            a = [utils.generate_anchors(j, n, fmt) for j in self.annfiles]
            self.ann_anchors = dict(zip(self.names, a))
        else:
            print(&#34;Loading pre-computed anchors&#34;)
            print(self.ann_anchors)

    def get_segmasks(self, palette=True):
        &#34;&#34;&#34;
        Function for generating segmentation masks.
        &#34;&#34;&#34;
        for ann, name in zip(self.annfiles, self.names):
            output_dir = self.res_dir / &#34;segmasks&#34; / name
            utils.det2seg(ann, output_dir, palette)

    def visualise(self):
        &#34;&#34;&#34;
        Function for visualising annotations.
        &#34;&#34;&#34;
        print(&#34;Choose directory index (1:first, 2: second ..):&#34;)
        print([s.stem for s in self.imgfolders])

        dir_choice = input()
        try:
            dir_choice = int(dir_choice) - 1
        except ValueError:
            sys.exit(&#34;Please specify an index&#34;)

        if dir_choice &gt; len(self.imgfolders):
            raise AssertionError(&#34;Index exceeds number of datasets&#34;)
        ann = self.annfiles[dir_choice]
        img_dir = self.imgfolders[dir_choice]
        cocovis.visualise_all(ann, img_dir)
        
    def category_subset(self, annotation_file, image_folder, input_cat, max_img_per_label=-1):
        &#34;&#34;&#34;
        Function to create subset of dataset with selected labels.
        annotation_file: Path to annotation_file.
        image_folder: Path to the image folder.
        input_cat: Comma seperated string of label names.
        max_img_per_label: Number of images per label. Default -1 meaning all taken.
        &#34;&#34;&#34;
        inp_categories = input_cat.split(&#39;,&#39;)
        print(&#34;inp_categories:&#34;, inp_categories)
        
        self.resim_dir = self.res_dir / Path(&#34;categories_&#34; + input_cat) / &#34;images&#34;
        self.resann_dir = self.res_dir / Path(&#34;categories_&#34; + input_cat) / &#34;annotations&#34;

        utils.make_clean(self.resim_dir)
        utils.make_clean(self.resann_dir)
        
        dst_ann = self.resann_dir / &#34;categories.json&#34;
        
        coco = COCO(annotation_file)
        categories = coco.loadCats(coco.getCatIds())
        category_dict = {}
        cat_Ids = []
        for category in categories:
            if category[&#39;name&#39;] in inp_categories:
                cat_Ids.append(category[&#39;id&#39;])
            category_dict[category[&#39;name&#39;]] = category[&#39;id&#39;]
        img_id_list = []
        category_list = coco.loadCats(ids=cat_Ids)
        for cat_id in cat_Ids:
            img_ids = coco.getImgIds(catIds=[cat_id])
            if max_img_per_label &gt; 0 and len(img_ids) &gt; max_img_per_label:
                img_ids = [img_ids[i] for i in sorted(
                    random.sample(range(len(img_ids)), max_img_per_label))]
            img_id_list = img_id_list + list(set(img_ids) - set(img_id_list))
        images = coco.loadImgs(ids=img_id_list)
        ann_ids = coco.getAnnIds(catIds=cat_Ids, imgIds=img_id_list)
        annotation_list = coco.loadAnns(ann_ids)
        print(&#39;copying images to:&#39;, self.resim_dir)
        for image in images:
            source = os.path.join(image_folder, image[&#39;file_name&#39;])
            destination = self.resim_dir / image[&#39;file_name&#39;]
            shutil.copyfile(source, destination)
            
        coco_data = {
            &#34;images&#34;: [],
            &#34;annotations&#34;: [],
            &#34;categories&#34;: []
        }
        coco_data[&#39;categories&#39;] = category_list
        coco_data[&#39;annotations&#39;] = annotation_list
        coco_data[&#39;images&#39;] = images
        with open(dst_ann, &#39;w&#39;) as outfile:
            json.dump(coco_data, outfile)
        print(&#34;Dataset created&#34;)

    def merge_same(self, output_folder=&#34;merged_same&#34;, merge_images=True):
        &#34;&#34;&#34;
        Function for merging multiple coco datasets
        &#34;&#34;&#34;
        self.resim_dir = Path(output_folder) / &#34;images&#34;
        self.resann_dir = Path(output_folder) / &#34;annotations&#34;

        utils.make_clean(self.resim_dir)
        utils.make_clean(self.resann_dir)

        duplicate_image_names = {}
        for i in range(1, len(self.imgfolders)):
            duplicate_image_names[i] = []

        if merge_images:
            print(&#34;Merging image dirs&#34;)
            im_dirs = self.imgfolders
            imext = [&#34;.png&#34;, &#34;.jpg&#34;, &#34;.jpeg&#34;]

            logging.debug(&#34;Merging Image Dirs...&#34;)

            for ind, imdir in enumerate(tqdm(im_dirs)):
                ims = [i for i in imdir.iterdir() if i.suffix.lower() in imext]
                for im in ims:
                    if os.path.isfile(self.resim_dir / im.name):
                        # im_name = im_name_copy = str(im.name)
                        # pos = im_name.rfind(&#39;.&#39;)
                        # for i in range(500):
                        #     if not os.path.isfile(os.path.join(self.resim_dir, im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:])):
                        #         im_name = im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:]
                        #         break
                        
                        duplicate_image_names[ind].append(str(im.name))
                    else:
                        im_name = im.name
                        shutil.copyfile(im, self.resim_dir / im_name)

        else:
            logging.debug(&#34;Not merging Image Dirs...&#34;)

        cann = {&#34;images&#34;: [], &#34;annotations&#34;: [], &#34;info&#34;: None, &#34;licenses&#34;: None, &#34;categories&#34;: None}

        logging.debug(&#34;Merging Annotations...&#34;)

        dst_ann = self.resann_dir / &#34;merged.json&#34;

        print(&#34;Merging annotations&#34;)
        for j in tqdm(self.jsonfiles):
            with open(j) as a:
                cj = json.load(a)

            ind = self.jsonfiles.index(j)
            # Check if this is the 1st annotation.
            # If it is, continue else modify current annotation
            if ind == 0:
                cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj[&#34;images&#34;]
                cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
                if &#34;info&#34; in list(cj.keys()):
                    cann[&#34;info&#34;] = cj[&#34;info&#34;]
                if &#34;licenses&#34; in list(cj.keys()):
                    cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]
                cann[&#34;categories&#34;] = sorted(cj[&#34;categories&#34;], key=lambda i: i[&#34;id&#34;])

                last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
                last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

                # If last imid or last_annid is a str, convert it to int
                if isinstance(last_imid, str) or isinstance(last_annid, str):
                    logging.debug(&#34;String Ids detected. Converting to int&#34;)
                    id_dict = {}
                    # Change image id in images field
                    for i, im in enumerate(cann[&#34;images&#34;]):
                        id_dict[im[&#34;id&#34;]] = i
                        im[&#34;id&#34;] = i

                    # Change annotation id &amp; image id in annotations field
                    for i, im in enumerate(cann[&#34;annotations&#34;]):
                        im[&#34;id&#34;] = i
                        if isinstance(last_imid, str):
                            im[&#34;image_id&#34;] = id_dict[im[&#34;image_id&#34;]]

                last_imid = max([im[&#34;id&#34;] for im in cann[&#34;images&#34;]])
                last_annid = max([ann[&#34;id&#34;] for ann in cann[&#34;annotations&#34;]])

            else:

                id_dict = {}
                cann_img_dict = {}
                for cann_img in cann[&#34;images&#34;]:
                    cann_img_dict[cann_img[&#34;file_name&#34;]] = cann_img[&#34;id&#34;]
                cj_notdup_img_list = []
                # Change image id in images field
                for i, im in enumerate(cj[&#34;images&#34;]):
                    if im[&#34;file_name&#34;] in duplicate_image_names[ind]:
                        # im[&#34;file_name&#34;] = duplicate_image_names[ind][im[&#34;file_name&#34;]]
                        id_dict[im[&#34;id&#34;]] = cann_img_dict[im[&#34;file_name&#34;]]
                    else:
                        id_dict[im[&#34;id&#34;]] = last_imid + i + 1
                        im[&#34;id&#34;] = last_imid + i + 1
                        cj_notdup_img_list.append(im)
                # Change annotation and image ids in annotations field
                for i, ann in enumerate(cj[&#34;annotations&#34;]):
                    ann[&#34;id&#34;] = last_annid + i + 1
                    ann[&#34;image_id&#34;] = id_dict[ann[&#34;image_id&#34;]]

                # Remap categories
                cmapper = utils.CatRemapper(cann[&#34;categories&#34;], cj[&#34;categories&#34;])
                cann[&#34;categories&#34;], cj[&#34;annotations&#34;] = cmapper.remap(cj[&#34;annotations&#34;])

                cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj_notdup_img_list
                cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
                if &#34;info&#34; in list(cj.keys()):
                    cann[&#34;info&#34;] = cj[&#34;info&#34;]
                if &#34;licenses&#34; in list(cj.keys()):
                    cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]

                last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
                last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

        with open(dst_ann, &#34;w&#34;) as aw:
            json.dump(cann, aw)
        


if __name__ == &#34;__main__&#34;:
    p = Path(&#34;/home/dori/Desktop/tester&#34;)
    img_dir = p / &#34;images&#34;
    ann_dir = p / &#34;annotations&#34;

    # TODO: Create tiny dummy datasets and test these functions on them

    cas = COCO_Assistant(img_dir, ann_dir)
    cas.merge_same()

    # cas.merge(False)
    # cas.remove_cat(interactive=False, jc=&#34;/home/vardan/Documents/genutils-analysis_plots/anno/coco_assistant/data/annotations/instances_default_2.json&#34;, rcats=[&#34;person&#34;])
    # cas.ann_stats(stat=&#34;area&#34;,arearng=[10,144,512,1e5],save=False)
    # cas.ann_stats(stat=&#34;cat&#34;, arearng=None, show_count=False, save=False)
    # cas.visualise()
    # cas.get_segmasks()
    # cas.anchors(2)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="data_handling.coco_assistant.coco_assistant.COCO_Assistant"><code class="flex name class">
<span>class <span class="ident">COCO_Assistant</span></span>
<span>(</span><span>img_dir, ann_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>:param img_dir (str): path to images folder.
:param ann_dir (str): path to annotations folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class COCO_Assistant:
    def __init__(self, img_dir, ann_dir):
        &#34;&#34;&#34;
        :param img_dir (str): path to images folder.
        :param ann_dir (str): path to annotations folder.
        &#34;&#34;&#34;
        self.img_dir = Path(img_dir)
        self.ann_dir = Path(ann_dir)

        # Parent dir should be the same
        if self.ann_dir.parents[0] != self.img_dir.parents[0]:
            raise AssertionError(&#34;Directory not in expected format&#34;)
        self.res_dir = self.ann_dir.parents[0]

        # Create Results Directory
        if not self.res_dir.exists():
            self.res_dir.mkdir()

        self.imgfolders = sorted(
            [i for i in self.img_dir.iterdir() if i.is_dir() and not i.name.startswith(&#34;.&#34;)]
        )
        imnames = [n.stem for n in self.imgfolders]

        self.jsonfiles = sorted([j for j in self.ann_dir.iterdir() if j.suffix == &#34;.json&#34;])
        jnames = [n.stem for n in self.jsonfiles]

        if imnames != jnames:
            raise AssertionError(&#34;Image dir and corresponding json file must have the same name&#34;)

        self.names = imnames

        # TODO: Add check for confirming these folders only contain .jpg and .json respectively
        logging.debug(&#34;Number of image folders = %s&#34;, len(self.imgfolders))
        logging.debug(&#34;Number of annotation files = %s&#34;, len(self.jsonfiles))

        if not self.jsonfiles:
            raise AssertionError(&#34;Annotation files not passed&#34;)
        if not self.imgfolders:
            raise AssertionError(&#34;Image folders not passed&#34;)

        self.annfiles = [COCO(i) for i in self.jsonfiles]
        self.anndict = dict(zip(self.jsonfiles, self.annfiles))

        self.ann_anchors = []

    def merge(self, output_folder=&#34;merged&#34;, merge_images=True, duplicate_frame=True):
        &#34;&#34;&#34;
        Function for merging multiple coco datasets
        &#34;&#34;&#34;
        self.resim_dir = Path(output_folder) / &#34;images&#34;
        self.resann_dir = Path(output_folder) / &#34;annotations&#34;

        utils.make_clean(self.resim_dir)
        utils.make_clean(self.resann_dir)

        duplicate_image_names = {}
        for i in range(1, len(self.imgfolders)):
            duplicate_image_names[i] = {}

        if merge_images:
            print(&#34;Merging image dirs&#34;)
            im_dirs = self.imgfolders
            imext = [&#34;.png&#34;, &#34;.jpg&#34;, &#34;.jpeg&#34;]

            logging.debug(&#34;Merging Image Dirs...&#34;)

            for ind, imdir in enumerate(tqdm(im_dirs)):
                ims = [i for i in imdir.iterdir() if i.suffix.lower() in imext]
                for im in ims:
                    if duplicate_frame:
                        if os.path.isfile(self.resim_dir / im.name):
                            im_name = im_name_copy = str(im.name)
                            pos = im_name.rfind(&#39;.&#39;)
                            for i in range(500):
                                if not os.path.isfile(os.path.join(self.resim_dir, im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:])):
                                    im_name = im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:]
                                    break
                            
                            duplicate_image_names[ind][im_name_copy] = im_name
                            im_name = Path(im_name)
                        else:
                            im_name = im.name
                    else:
                        im_name = im.name

                    shutil.copyfile(im, self.resim_dir / im_name)

        else:
            logging.debug(&#34;Not merging Image Dirs...&#34;)

        cann = {&#34;images&#34;: [], &#34;annotations&#34;: [], &#34;info&#34;: None, &#34;licenses&#34;: None, &#34;categories&#34;: None}

        logging.debug(&#34;Merging Annotations...&#34;)

        dst_ann = self.resann_dir / &#34;merged.json&#34;

        print(&#34;Merging annotations&#34;)
        for j in tqdm(self.jsonfiles):
            with open(j) as a:
                cj = json.load(a)

            ind = self.jsonfiles.index(j)
            # Check if this is the 1st annotation.
            # If it is, continue else modify current annotation
            if ind == 0:
                cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj[&#34;images&#34;]
                cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
                if &#34;info&#34; in list(cj.keys()):
                    cann[&#34;info&#34;] = cj[&#34;info&#34;]
                if &#34;licenses&#34; in list(cj.keys()):
                    cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]
                cann[&#34;categories&#34;] = sorted(cj[&#34;categories&#34;], key=lambda i: i[&#34;id&#34;])

                last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
                last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

                # If last imid or last_annid is a str, convert it to int
                if isinstance(last_imid, str) or isinstance(last_annid, str):
                    logging.debug(&#34;String Ids detected. Converting to int&#34;)
                    id_dict = {}
                    # Change image id in images field
                    for i, im in enumerate(cann[&#34;images&#34;]):
                        id_dict[im[&#34;id&#34;]] = i
                        im[&#34;id&#34;] = i

                    # Change annotation id &amp; image id in annotations field
                    for i, im in enumerate(cann[&#34;annotations&#34;]):
                        im[&#34;id&#34;] = i
                        if isinstance(last_imid, str):
                            im[&#34;image_id&#34;] = id_dict[im[&#34;image_id&#34;]]

                last_imid = max([im[&#34;id&#34;] for im in cann[&#34;images&#34;]])
                last_annid = max([ann[&#34;id&#34;] for ann in cann[&#34;annotations&#34;]])

            else:

                id_dict = {}
                # Change image id in images field
                for i, im in enumerate(cj[&#34;images&#34;]):
                    id_dict[im[&#34;id&#34;]] = last_imid + i + 1
                    im[&#34;id&#34;] = last_imid + i + 1
                    if duplicate_frame:
                        if im[&#34;file_name&#34;] in duplicate_image_names[ind]:
                            im[&#34;file_name&#34;] = duplicate_image_names[ind][im[&#34;file_name&#34;]]

                # Change annotation and image ids in annotations field
                for i, ann in enumerate(cj[&#34;annotations&#34;]):
                    ann[&#34;id&#34;] = last_annid + i + 1
                    ann[&#34;image_id&#34;] = id_dict[ann[&#34;image_id&#34;]]

                # Remap categories
                cmapper = utils.CatRemapper(cann[&#34;categories&#34;], cj[&#34;categories&#34;])
                cann[&#34;categories&#34;], cj[&#34;annotations&#34;] = cmapper.remap(cj[&#34;annotations&#34;])

                cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj[&#34;images&#34;]
                cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
                if &#34;info&#34; in list(cj.keys()):
                    cann[&#34;info&#34;] = cj[&#34;info&#34;]
                if &#34;licenses&#34; in list(cj.keys()):
                    cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]

                last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
                last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

        with open(dst_ann, &#34;w&#34;) as aw:
            json.dump(cann, aw)

    def remove_cat(self, interactive=True, remove_empty_frames=True, jc=None, rcats=None):
        &#34;&#34;&#34;
        Function for removing certain categories.
        In interactive mode, you can input the json and the categories
        to be removed (as a list, see README for example)
        In non-interactive mode, you manually pass in json filename and
        categories to be removed. Note that jc and
        rcats cannot be None if run with interactive=False.

        :param interactive: Run category removal in interactive mode
        :param remove_empty_frames: Remove frames which do not have annotations after removing category
        :param jc: Json choice
        :param rcats: Categories to be removed
        &#34;&#34;&#34;
        resrm_dir = self.res_dir / &#34;removal&#34;
        utils.make_clean(resrm_dir)
        # jnames == imnames -&gt; No extension

        if interactive:
            print(self.names)
            print(&#34;Choose directory index (1:first, 2: second ..)&#34;)

            json_choice = input()
            try:
                json_choice = int(json_choice) - 1
            except ValueError:
                sys.exit(&#34;Please specify an index&#34;)

            if json_choice &gt; len(self.names):
                raise AssertionError(&#34;Index exceeds number of datasets&#34;)
            ann = self.annfiles[json_choice]
            json_name = self.jsonfiles[json_choice].name
            self.jc = json_name  # hack

            print(&#34;\nCategories present:&#34;)
            cats = [i[&#34;name&#34;] for i in ann.cats.values()]
            print(cats)

            self.rcats = []
            print(&#34;\nEnter categories you wish to remove as a list:&#34;)
            x = input()
            x = ast.literal_eval(x)
            if isinstance(x, list) is False:
                raise AssertionError(&#34;Input must be a list of categories to be removed&#34;)
            if all(elem in cats for elem in x):
                self.rcats = x
            else:
                print(&#34;Incorrect entry.&#34;)

        else:
            if jc is None or rcats is None:
                raise AssertionError(
                    &#34;Both json choice and rcats need to be provided in non-interactive mode&#34;
                )
            # If passed, json_choice needs to be full path
            json_choice = Path(jc)  # Full path
            json_name = json_choice.name  # abc.json
            self.jc = json_name  # hack
            ann = self.anndict[Path(json_choice)]
            self.rcats = rcats

            img_folder = self.imgfolders[self.jsonfiles.index(json_choice)]

        print(&#34;Removing specified categories...&#34;)

        # Gives you a list of category ids of the categories to be removed
        catids_remove = ann.getCatIds(catNms=self.rcats)
        # Gives you a list of ids of annotations that contain those categories
        annids_remove = ann.getAnnIds(catIds=catids_remove)

        # Get keep category ids
        catids_keep = list(set(ann.getCatIds()) - set(catids_remove))
        # Get keep annotation ids
        annids_keep = list(set(ann.getAnnIds()) - set(annids_remove))

        with open(self.ann_dir / json_name) as it:
            x = json.load(it)

        del x[&#34;categories&#34;]
        x[&#34;categories&#34;] = ann.loadCats(catids_keep)
        del x[&#34;annotations&#34;]
        x[&#34;annotations&#34;] = ann.loadAnns(annids_keep)

        if remove_empty_frames:
            image_ids = []
            image_file_names = []
            for annotation in x[&#34;annotations&#34;]:
                image_ids.append(annotation[&#34;image_id&#34;])
            image_ids = list(set(image_ids))
            remove_image_ids = ann.getImgIds(catIds=catids_remove)
            all_image_ids = ann.getImgIds()
            
            del x[&#34;images&#34;]
            x[&#34;images&#34;] = ann.loadImgs(list(set(image_ids).union(set(all_image_ids) - set(remove_image_ids))))

            for image in x[&#34;images&#34;]:
                image_file_names.append(image[&#34;file_name&#34;])
            
            # img_folder = json_name
            all_image_names = os.listdir(img_folder)
            for single_image_name in all_image_names:
                if single_image_name not in image_file_names:
                    os.remove(img_folder / Path(single_image_name))
        

        with open(resrm_dir / json_name, &#34;w&#34;) as oa:
            json.dump(x, oa)

    def ann_stats(self, stat, arearng, show_count=False, save=False):
        &#34;&#34;&#34;
        Function for displaying statistics.
        &#34;&#34;&#34;
        if stat == &#34;area&#34;:
            stats.pi_area_split(self.annfiles, self.names, areaRng=arearng, save=save)
        elif stat == &#34;cat&#34;:
            stats.cat_count(self.annfiles, self.names, show_count=show_count, save=save)

    def anchors(self, n, fmt=None, recompute=False):
        &#34;&#34;&#34;
        Function for generating top &#39;n&#39; anchors

        :param n: Number of anchors
        :param fmt: Format of anchors [&#39;square&#39;, None]
        :param recompute: Rerun k-means and recompute anchors
        &#34;&#34;&#34;
        if recompute or not self.ann_anchors:
            print(&#34;Calculating anchors...&#34;)
            a = [utils.generate_anchors(j, n, fmt) for j in self.annfiles]
            self.ann_anchors = dict(zip(self.names, a))
        else:
            print(&#34;Loading pre-computed anchors&#34;)
            print(self.ann_anchors)

    def get_segmasks(self, palette=True):
        &#34;&#34;&#34;
        Function for generating segmentation masks.
        &#34;&#34;&#34;
        for ann, name in zip(self.annfiles, self.names):
            output_dir = self.res_dir / &#34;segmasks&#34; / name
            utils.det2seg(ann, output_dir, palette)

    def visualise(self):
        &#34;&#34;&#34;
        Function for visualising annotations.
        &#34;&#34;&#34;
        print(&#34;Choose directory index (1:first, 2: second ..):&#34;)
        print([s.stem for s in self.imgfolders])

        dir_choice = input()
        try:
            dir_choice = int(dir_choice) - 1
        except ValueError:
            sys.exit(&#34;Please specify an index&#34;)

        if dir_choice &gt; len(self.imgfolders):
            raise AssertionError(&#34;Index exceeds number of datasets&#34;)
        ann = self.annfiles[dir_choice]
        img_dir = self.imgfolders[dir_choice]
        cocovis.visualise_all(ann, img_dir)
        
    def category_subset(self, annotation_file, image_folder, input_cat, max_img_per_label=-1):
        &#34;&#34;&#34;
        Function to create subset of dataset with selected labels.
        annotation_file: Path to annotation_file.
        image_folder: Path to the image folder.
        input_cat: Comma seperated string of label names.
        max_img_per_label: Number of images per label. Default -1 meaning all taken.
        &#34;&#34;&#34;
        inp_categories = input_cat.split(&#39;,&#39;)
        print(&#34;inp_categories:&#34;, inp_categories)
        
        self.resim_dir = self.res_dir / Path(&#34;categories_&#34; + input_cat) / &#34;images&#34;
        self.resann_dir = self.res_dir / Path(&#34;categories_&#34; + input_cat) / &#34;annotations&#34;

        utils.make_clean(self.resim_dir)
        utils.make_clean(self.resann_dir)
        
        dst_ann = self.resann_dir / &#34;categories.json&#34;
        
        coco = COCO(annotation_file)
        categories = coco.loadCats(coco.getCatIds())
        category_dict = {}
        cat_Ids = []
        for category in categories:
            if category[&#39;name&#39;] in inp_categories:
                cat_Ids.append(category[&#39;id&#39;])
            category_dict[category[&#39;name&#39;]] = category[&#39;id&#39;]
        img_id_list = []
        category_list = coco.loadCats(ids=cat_Ids)
        for cat_id in cat_Ids:
            img_ids = coco.getImgIds(catIds=[cat_id])
            if max_img_per_label &gt; 0 and len(img_ids) &gt; max_img_per_label:
                img_ids = [img_ids[i] for i in sorted(
                    random.sample(range(len(img_ids)), max_img_per_label))]
            img_id_list = img_id_list + list(set(img_ids) - set(img_id_list))
        images = coco.loadImgs(ids=img_id_list)
        ann_ids = coco.getAnnIds(catIds=cat_Ids, imgIds=img_id_list)
        annotation_list = coco.loadAnns(ann_ids)
        print(&#39;copying images to:&#39;, self.resim_dir)
        for image in images:
            source = os.path.join(image_folder, image[&#39;file_name&#39;])
            destination = self.resim_dir / image[&#39;file_name&#39;]
            shutil.copyfile(source, destination)
            
        coco_data = {
            &#34;images&#34;: [],
            &#34;annotations&#34;: [],
            &#34;categories&#34;: []
        }
        coco_data[&#39;categories&#39;] = category_list
        coco_data[&#39;annotations&#39;] = annotation_list
        coco_data[&#39;images&#39;] = images
        with open(dst_ann, &#39;w&#39;) as outfile:
            json.dump(coco_data, outfile)
        print(&#34;Dataset created&#34;)

    def merge_same(self, output_folder=&#34;merged_same&#34;, merge_images=True):
        &#34;&#34;&#34;
        Function for merging multiple coco datasets
        &#34;&#34;&#34;
        self.resim_dir = Path(output_folder) / &#34;images&#34;
        self.resann_dir = Path(output_folder) / &#34;annotations&#34;

        utils.make_clean(self.resim_dir)
        utils.make_clean(self.resann_dir)

        duplicate_image_names = {}
        for i in range(1, len(self.imgfolders)):
            duplicate_image_names[i] = []

        if merge_images:
            print(&#34;Merging image dirs&#34;)
            im_dirs = self.imgfolders
            imext = [&#34;.png&#34;, &#34;.jpg&#34;, &#34;.jpeg&#34;]

            logging.debug(&#34;Merging Image Dirs...&#34;)

            for ind, imdir in enumerate(tqdm(im_dirs)):
                ims = [i for i in imdir.iterdir() if i.suffix.lower() in imext]
                for im in ims:
                    if os.path.isfile(self.resim_dir / im.name):
                        # im_name = im_name_copy = str(im.name)
                        # pos = im_name.rfind(&#39;.&#39;)
                        # for i in range(500):
                        #     if not os.path.isfile(os.path.join(self.resim_dir, im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:])):
                        #         im_name = im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:]
                        #         break
                        
                        duplicate_image_names[ind].append(str(im.name))
                    else:
                        im_name = im.name
                        shutil.copyfile(im, self.resim_dir / im_name)

        else:
            logging.debug(&#34;Not merging Image Dirs...&#34;)

        cann = {&#34;images&#34;: [], &#34;annotations&#34;: [], &#34;info&#34;: None, &#34;licenses&#34;: None, &#34;categories&#34;: None}

        logging.debug(&#34;Merging Annotations...&#34;)

        dst_ann = self.resann_dir / &#34;merged.json&#34;

        print(&#34;Merging annotations&#34;)
        for j in tqdm(self.jsonfiles):
            with open(j) as a:
                cj = json.load(a)

            ind = self.jsonfiles.index(j)
            # Check if this is the 1st annotation.
            # If it is, continue else modify current annotation
            if ind == 0:
                cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj[&#34;images&#34;]
                cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
                if &#34;info&#34; in list(cj.keys()):
                    cann[&#34;info&#34;] = cj[&#34;info&#34;]
                if &#34;licenses&#34; in list(cj.keys()):
                    cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]
                cann[&#34;categories&#34;] = sorted(cj[&#34;categories&#34;], key=lambda i: i[&#34;id&#34;])

                last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
                last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

                # If last imid or last_annid is a str, convert it to int
                if isinstance(last_imid, str) or isinstance(last_annid, str):
                    logging.debug(&#34;String Ids detected. Converting to int&#34;)
                    id_dict = {}
                    # Change image id in images field
                    for i, im in enumerate(cann[&#34;images&#34;]):
                        id_dict[im[&#34;id&#34;]] = i
                        im[&#34;id&#34;] = i

                    # Change annotation id &amp; image id in annotations field
                    for i, im in enumerate(cann[&#34;annotations&#34;]):
                        im[&#34;id&#34;] = i
                        if isinstance(last_imid, str):
                            im[&#34;image_id&#34;] = id_dict[im[&#34;image_id&#34;]]

                last_imid = max([im[&#34;id&#34;] for im in cann[&#34;images&#34;]])
                last_annid = max([ann[&#34;id&#34;] for ann in cann[&#34;annotations&#34;]])

            else:

                id_dict = {}
                cann_img_dict = {}
                for cann_img in cann[&#34;images&#34;]:
                    cann_img_dict[cann_img[&#34;file_name&#34;]] = cann_img[&#34;id&#34;]
                cj_notdup_img_list = []
                # Change image id in images field
                for i, im in enumerate(cj[&#34;images&#34;]):
                    if im[&#34;file_name&#34;] in duplicate_image_names[ind]:
                        # im[&#34;file_name&#34;] = duplicate_image_names[ind][im[&#34;file_name&#34;]]
                        id_dict[im[&#34;id&#34;]] = cann_img_dict[im[&#34;file_name&#34;]]
                    else:
                        id_dict[im[&#34;id&#34;]] = last_imid + i + 1
                        im[&#34;id&#34;] = last_imid + i + 1
                        cj_notdup_img_list.append(im)
                # Change annotation and image ids in annotations field
                for i, ann in enumerate(cj[&#34;annotations&#34;]):
                    ann[&#34;id&#34;] = last_annid + i + 1
                    ann[&#34;image_id&#34;] = id_dict[ann[&#34;image_id&#34;]]

                # Remap categories
                cmapper = utils.CatRemapper(cann[&#34;categories&#34;], cj[&#34;categories&#34;])
                cann[&#34;categories&#34;], cj[&#34;annotations&#34;] = cmapper.remap(cj[&#34;annotations&#34;])

                cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj_notdup_img_list
                cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
                if &#34;info&#34; in list(cj.keys()):
                    cann[&#34;info&#34;] = cj[&#34;info&#34;]
                if &#34;licenses&#34; in list(cj.keys()):
                    cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]

                last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
                last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

        with open(dst_ann, &#34;w&#34;) as aw:
            json.dump(cann, aw)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="data_handling.coco_assistant.coco_assistant.COCO_Assistant.anchors"><code class="name flex">
<span>def <span class="ident">anchors</span></span>(<span>self, n, fmt=None, recompute=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for generating top 'n' anchors</p>
<p>:param n: Number of anchors
:param fmt: Format of anchors ['square', None]
:param recompute: Rerun k-means and recompute anchors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anchors(self, n, fmt=None, recompute=False):
    &#34;&#34;&#34;
    Function for generating top &#39;n&#39; anchors

    :param n: Number of anchors
    :param fmt: Format of anchors [&#39;square&#39;, None]
    :param recompute: Rerun k-means and recompute anchors
    &#34;&#34;&#34;
    if recompute or not self.ann_anchors:
        print(&#34;Calculating anchors...&#34;)
        a = [utils.generate_anchors(j, n, fmt) for j in self.annfiles]
        self.ann_anchors = dict(zip(self.names, a))
    else:
        print(&#34;Loading pre-computed anchors&#34;)
        print(self.ann_anchors)</code></pre>
</details>
</dd>
<dt id="data_handling.coco_assistant.coco_assistant.COCO_Assistant.ann_stats"><code class="name flex">
<span>def <span class="ident">ann_stats</span></span>(<span>self, stat, arearng, show_count=False, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for displaying statistics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ann_stats(self, stat, arearng, show_count=False, save=False):
    &#34;&#34;&#34;
    Function for displaying statistics.
    &#34;&#34;&#34;
    if stat == &#34;area&#34;:
        stats.pi_area_split(self.annfiles, self.names, areaRng=arearng, save=save)
    elif stat == &#34;cat&#34;:
        stats.cat_count(self.annfiles, self.names, show_count=show_count, save=save)</code></pre>
</details>
</dd>
<dt id="data_handling.coco_assistant.coco_assistant.COCO_Assistant.category_subset"><code class="name flex">
<span>def <span class="ident">category_subset</span></span>(<span>self, annotation_file, image_folder, input_cat, max_img_per_label=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create subset of dataset with selected labels.
annotation_file: Path to annotation_file.
image_folder: Path to the image folder.
input_cat: Comma seperated string of label names.
max_img_per_label: Number of images per label. Default -1 meaning all taken.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def category_subset(self, annotation_file, image_folder, input_cat, max_img_per_label=-1):
    &#34;&#34;&#34;
    Function to create subset of dataset with selected labels.
    annotation_file: Path to annotation_file.
    image_folder: Path to the image folder.
    input_cat: Comma seperated string of label names.
    max_img_per_label: Number of images per label. Default -1 meaning all taken.
    &#34;&#34;&#34;
    inp_categories = input_cat.split(&#39;,&#39;)
    print(&#34;inp_categories:&#34;, inp_categories)
    
    self.resim_dir = self.res_dir / Path(&#34;categories_&#34; + input_cat) / &#34;images&#34;
    self.resann_dir = self.res_dir / Path(&#34;categories_&#34; + input_cat) / &#34;annotations&#34;

    utils.make_clean(self.resim_dir)
    utils.make_clean(self.resann_dir)
    
    dst_ann = self.resann_dir / &#34;categories.json&#34;
    
    coco = COCO(annotation_file)
    categories = coco.loadCats(coco.getCatIds())
    category_dict = {}
    cat_Ids = []
    for category in categories:
        if category[&#39;name&#39;] in inp_categories:
            cat_Ids.append(category[&#39;id&#39;])
        category_dict[category[&#39;name&#39;]] = category[&#39;id&#39;]
    img_id_list = []
    category_list = coco.loadCats(ids=cat_Ids)
    for cat_id in cat_Ids:
        img_ids = coco.getImgIds(catIds=[cat_id])
        if max_img_per_label &gt; 0 and len(img_ids) &gt; max_img_per_label:
            img_ids = [img_ids[i] for i in sorted(
                random.sample(range(len(img_ids)), max_img_per_label))]
        img_id_list = img_id_list + list(set(img_ids) - set(img_id_list))
    images = coco.loadImgs(ids=img_id_list)
    ann_ids = coco.getAnnIds(catIds=cat_Ids, imgIds=img_id_list)
    annotation_list = coco.loadAnns(ann_ids)
    print(&#39;copying images to:&#39;, self.resim_dir)
    for image in images:
        source = os.path.join(image_folder, image[&#39;file_name&#39;])
        destination = self.resim_dir / image[&#39;file_name&#39;]
        shutil.copyfile(source, destination)
        
    coco_data = {
        &#34;images&#34;: [],
        &#34;annotations&#34;: [],
        &#34;categories&#34;: []
    }
    coco_data[&#39;categories&#39;] = category_list
    coco_data[&#39;annotations&#39;] = annotation_list
    coco_data[&#39;images&#39;] = images
    with open(dst_ann, &#39;w&#39;) as outfile:
        json.dump(coco_data, outfile)
    print(&#34;Dataset created&#34;)</code></pre>
</details>
</dd>
<dt id="data_handling.coco_assistant.coco_assistant.COCO_Assistant.get_segmasks"><code class="name flex">
<span>def <span class="ident">get_segmasks</span></span>(<span>self, palette=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for generating segmentation masks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_segmasks(self, palette=True):
    &#34;&#34;&#34;
    Function for generating segmentation masks.
    &#34;&#34;&#34;
    for ann, name in zip(self.annfiles, self.names):
        output_dir = self.res_dir / &#34;segmasks&#34; / name
        utils.det2seg(ann, output_dir, palette)</code></pre>
</details>
</dd>
<dt id="data_handling.coco_assistant.coco_assistant.COCO_Assistant.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, output_folder='merged', merge_images=True, duplicate_frame=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for merging multiple coco datasets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, output_folder=&#34;merged&#34;, merge_images=True, duplicate_frame=True):
    &#34;&#34;&#34;
    Function for merging multiple coco datasets
    &#34;&#34;&#34;
    self.resim_dir = Path(output_folder) / &#34;images&#34;
    self.resann_dir = Path(output_folder) / &#34;annotations&#34;

    utils.make_clean(self.resim_dir)
    utils.make_clean(self.resann_dir)

    duplicate_image_names = {}
    for i in range(1, len(self.imgfolders)):
        duplicate_image_names[i] = {}

    if merge_images:
        print(&#34;Merging image dirs&#34;)
        im_dirs = self.imgfolders
        imext = [&#34;.png&#34;, &#34;.jpg&#34;, &#34;.jpeg&#34;]

        logging.debug(&#34;Merging Image Dirs...&#34;)

        for ind, imdir in enumerate(tqdm(im_dirs)):
            ims = [i for i in imdir.iterdir() if i.suffix.lower() in imext]
            for im in ims:
                if duplicate_frame:
                    if os.path.isfile(self.resim_dir / im.name):
                        im_name = im_name_copy = str(im.name)
                        pos = im_name.rfind(&#39;.&#39;)
                        for i in range(500):
                            if not os.path.isfile(os.path.join(self.resim_dir, im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:])):
                                im_name = im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:]
                                break
                        
                        duplicate_image_names[ind][im_name_copy] = im_name
                        im_name = Path(im_name)
                    else:
                        im_name = im.name
                else:
                    im_name = im.name

                shutil.copyfile(im, self.resim_dir / im_name)

    else:
        logging.debug(&#34;Not merging Image Dirs...&#34;)

    cann = {&#34;images&#34;: [], &#34;annotations&#34;: [], &#34;info&#34;: None, &#34;licenses&#34;: None, &#34;categories&#34;: None}

    logging.debug(&#34;Merging Annotations...&#34;)

    dst_ann = self.resann_dir / &#34;merged.json&#34;

    print(&#34;Merging annotations&#34;)
    for j in tqdm(self.jsonfiles):
        with open(j) as a:
            cj = json.load(a)

        ind = self.jsonfiles.index(j)
        # Check if this is the 1st annotation.
        # If it is, continue else modify current annotation
        if ind == 0:
            cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj[&#34;images&#34;]
            cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
            if &#34;info&#34; in list(cj.keys()):
                cann[&#34;info&#34;] = cj[&#34;info&#34;]
            if &#34;licenses&#34; in list(cj.keys()):
                cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]
            cann[&#34;categories&#34;] = sorted(cj[&#34;categories&#34;], key=lambda i: i[&#34;id&#34;])

            last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
            last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

            # If last imid or last_annid is a str, convert it to int
            if isinstance(last_imid, str) or isinstance(last_annid, str):
                logging.debug(&#34;String Ids detected. Converting to int&#34;)
                id_dict = {}
                # Change image id in images field
                for i, im in enumerate(cann[&#34;images&#34;]):
                    id_dict[im[&#34;id&#34;]] = i
                    im[&#34;id&#34;] = i

                # Change annotation id &amp; image id in annotations field
                for i, im in enumerate(cann[&#34;annotations&#34;]):
                    im[&#34;id&#34;] = i
                    if isinstance(last_imid, str):
                        im[&#34;image_id&#34;] = id_dict[im[&#34;image_id&#34;]]

            last_imid = max([im[&#34;id&#34;] for im in cann[&#34;images&#34;]])
            last_annid = max([ann[&#34;id&#34;] for ann in cann[&#34;annotations&#34;]])

        else:

            id_dict = {}
            # Change image id in images field
            for i, im in enumerate(cj[&#34;images&#34;]):
                id_dict[im[&#34;id&#34;]] = last_imid + i + 1
                im[&#34;id&#34;] = last_imid + i + 1
                if duplicate_frame:
                    if im[&#34;file_name&#34;] in duplicate_image_names[ind]:
                        im[&#34;file_name&#34;] = duplicate_image_names[ind][im[&#34;file_name&#34;]]

            # Change annotation and image ids in annotations field
            for i, ann in enumerate(cj[&#34;annotations&#34;]):
                ann[&#34;id&#34;] = last_annid + i + 1
                ann[&#34;image_id&#34;] = id_dict[ann[&#34;image_id&#34;]]

            # Remap categories
            cmapper = utils.CatRemapper(cann[&#34;categories&#34;], cj[&#34;categories&#34;])
            cann[&#34;categories&#34;], cj[&#34;annotations&#34;] = cmapper.remap(cj[&#34;annotations&#34;])

            cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj[&#34;images&#34;]
            cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
            if &#34;info&#34; in list(cj.keys()):
                cann[&#34;info&#34;] = cj[&#34;info&#34;]
            if &#34;licenses&#34; in list(cj.keys()):
                cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]

            last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
            last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

    with open(dst_ann, &#34;w&#34;) as aw:
        json.dump(cann, aw)</code></pre>
</details>
</dd>
<dt id="data_handling.coco_assistant.coco_assistant.COCO_Assistant.merge_same"><code class="name flex">
<span>def <span class="ident">merge_same</span></span>(<span>self, output_folder='merged_same', merge_images=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for merging multiple coco datasets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_same(self, output_folder=&#34;merged_same&#34;, merge_images=True):
    &#34;&#34;&#34;
    Function for merging multiple coco datasets
    &#34;&#34;&#34;
    self.resim_dir = Path(output_folder) / &#34;images&#34;
    self.resann_dir = Path(output_folder) / &#34;annotations&#34;

    utils.make_clean(self.resim_dir)
    utils.make_clean(self.resann_dir)

    duplicate_image_names = {}
    for i in range(1, len(self.imgfolders)):
        duplicate_image_names[i] = []

    if merge_images:
        print(&#34;Merging image dirs&#34;)
        im_dirs = self.imgfolders
        imext = [&#34;.png&#34;, &#34;.jpg&#34;, &#34;.jpeg&#34;]

        logging.debug(&#34;Merging Image Dirs...&#34;)

        for ind, imdir in enumerate(tqdm(im_dirs)):
            ims = [i for i in imdir.iterdir() if i.suffix.lower() in imext]
            for im in ims:
                if os.path.isfile(self.resim_dir / im.name):
                    # im_name = im_name_copy = str(im.name)
                    # pos = im_name.rfind(&#39;.&#39;)
                    # for i in range(500):
                    #     if not os.path.isfile(os.path.join(self.resim_dir, im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:])):
                    #         im_name = im_name[:pos] + &#39;_&#39;+str(i) + im_name[pos:]
                    #         break
                    
                    duplicate_image_names[ind].append(str(im.name))
                else:
                    im_name = im.name
                    shutil.copyfile(im, self.resim_dir / im_name)

    else:
        logging.debug(&#34;Not merging Image Dirs...&#34;)

    cann = {&#34;images&#34;: [], &#34;annotations&#34;: [], &#34;info&#34;: None, &#34;licenses&#34;: None, &#34;categories&#34;: None}

    logging.debug(&#34;Merging Annotations...&#34;)

    dst_ann = self.resann_dir / &#34;merged.json&#34;

    print(&#34;Merging annotations&#34;)
    for j in tqdm(self.jsonfiles):
        with open(j) as a:
            cj = json.load(a)

        ind = self.jsonfiles.index(j)
        # Check if this is the 1st annotation.
        # If it is, continue else modify current annotation
        if ind == 0:
            cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj[&#34;images&#34;]
            cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
            if &#34;info&#34; in list(cj.keys()):
                cann[&#34;info&#34;] = cj[&#34;info&#34;]
            if &#34;licenses&#34; in list(cj.keys()):
                cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]
            cann[&#34;categories&#34;] = sorted(cj[&#34;categories&#34;], key=lambda i: i[&#34;id&#34;])

            last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
            last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

            # If last imid or last_annid is a str, convert it to int
            if isinstance(last_imid, str) or isinstance(last_annid, str):
                logging.debug(&#34;String Ids detected. Converting to int&#34;)
                id_dict = {}
                # Change image id in images field
                for i, im in enumerate(cann[&#34;images&#34;]):
                    id_dict[im[&#34;id&#34;]] = i
                    im[&#34;id&#34;] = i

                # Change annotation id &amp; image id in annotations field
                for i, im in enumerate(cann[&#34;annotations&#34;]):
                    im[&#34;id&#34;] = i
                    if isinstance(last_imid, str):
                        im[&#34;image_id&#34;] = id_dict[im[&#34;image_id&#34;]]

            last_imid = max([im[&#34;id&#34;] for im in cann[&#34;images&#34;]])
            last_annid = max([ann[&#34;id&#34;] for ann in cann[&#34;annotations&#34;]])

        else:

            id_dict = {}
            cann_img_dict = {}
            for cann_img in cann[&#34;images&#34;]:
                cann_img_dict[cann_img[&#34;file_name&#34;]] = cann_img[&#34;id&#34;]
            cj_notdup_img_list = []
            # Change image id in images field
            for i, im in enumerate(cj[&#34;images&#34;]):
                if im[&#34;file_name&#34;] in duplicate_image_names[ind]:
                    # im[&#34;file_name&#34;] = duplicate_image_names[ind][im[&#34;file_name&#34;]]
                    id_dict[im[&#34;id&#34;]] = cann_img_dict[im[&#34;file_name&#34;]]
                else:
                    id_dict[im[&#34;id&#34;]] = last_imid + i + 1
                    im[&#34;id&#34;] = last_imid + i + 1
                    cj_notdup_img_list.append(im)
            # Change annotation and image ids in annotations field
            for i, ann in enumerate(cj[&#34;annotations&#34;]):
                ann[&#34;id&#34;] = last_annid + i + 1
                ann[&#34;image_id&#34;] = id_dict[ann[&#34;image_id&#34;]]

            # Remap categories
            cmapper = utils.CatRemapper(cann[&#34;categories&#34;], cj[&#34;categories&#34;])
            cann[&#34;categories&#34;], cj[&#34;annotations&#34;] = cmapper.remap(cj[&#34;annotations&#34;])

            cann[&#34;images&#34;] = cann[&#34;images&#34;] + cj_notdup_img_list
            cann[&#34;annotations&#34;] = cann[&#34;annotations&#34;] + cj[&#34;annotations&#34;]
            if &#34;info&#34; in list(cj.keys()):
                cann[&#34;info&#34;] = cj[&#34;info&#34;]
            if &#34;licenses&#34; in list(cj.keys()):
                cann[&#34;licenses&#34;] = cj[&#34;licenses&#34;]

            last_imid = cann[&#34;images&#34;][-1][&#34;id&#34;]
            last_annid = cann[&#34;annotations&#34;][-1][&#34;id&#34;]

    with open(dst_ann, &#34;w&#34;) as aw:
        json.dump(cann, aw)</code></pre>
</details>
</dd>
<dt id="data_handling.coco_assistant.coco_assistant.COCO_Assistant.remove_cat"><code class="name flex">
<span>def <span class="ident">remove_cat</span></span>(<span>self, interactive=True, remove_empty_frames=True, jc=None, rcats=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for removing certain categories.
In interactive mode, you can input the json and the categories
to be removed (as a list, see README for example)
In non-interactive mode, you manually pass in json filename and
categories to be removed. Note that jc and
rcats cannot be None if run with interactive=False.</p>
<p>:param interactive: Run category removal in interactive mode
:param remove_empty_frames: Remove frames which do not have annotations after removing category
:param jc: Json choice
:param rcats: Categories to be removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_cat(self, interactive=True, remove_empty_frames=True, jc=None, rcats=None):
    &#34;&#34;&#34;
    Function for removing certain categories.
    In interactive mode, you can input the json and the categories
    to be removed (as a list, see README for example)
    In non-interactive mode, you manually pass in json filename and
    categories to be removed. Note that jc and
    rcats cannot be None if run with interactive=False.

    :param interactive: Run category removal in interactive mode
    :param remove_empty_frames: Remove frames which do not have annotations after removing category
    :param jc: Json choice
    :param rcats: Categories to be removed
    &#34;&#34;&#34;
    resrm_dir = self.res_dir / &#34;removal&#34;
    utils.make_clean(resrm_dir)
    # jnames == imnames -&gt; No extension

    if interactive:
        print(self.names)
        print(&#34;Choose directory index (1:first, 2: second ..)&#34;)

        json_choice = input()
        try:
            json_choice = int(json_choice) - 1
        except ValueError:
            sys.exit(&#34;Please specify an index&#34;)

        if json_choice &gt; len(self.names):
            raise AssertionError(&#34;Index exceeds number of datasets&#34;)
        ann = self.annfiles[json_choice]
        json_name = self.jsonfiles[json_choice].name
        self.jc = json_name  # hack

        print(&#34;\nCategories present:&#34;)
        cats = [i[&#34;name&#34;] for i in ann.cats.values()]
        print(cats)

        self.rcats = []
        print(&#34;\nEnter categories you wish to remove as a list:&#34;)
        x = input()
        x = ast.literal_eval(x)
        if isinstance(x, list) is False:
            raise AssertionError(&#34;Input must be a list of categories to be removed&#34;)
        if all(elem in cats for elem in x):
            self.rcats = x
        else:
            print(&#34;Incorrect entry.&#34;)

    else:
        if jc is None or rcats is None:
            raise AssertionError(
                &#34;Both json choice and rcats need to be provided in non-interactive mode&#34;
            )
        # If passed, json_choice needs to be full path
        json_choice = Path(jc)  # Full path
        json_name = json_choice.name  # abc.json
        self.jc = json_name  # hack
        ann = self.anndict[Path(json_choice)]
        self.rcats = rcats

        img_folder = self.imgfolders[self.jsonfiles.index(json_choice)]

    print(&#34;Removing specified categories...&#34;)

    # Gives you a list of category ids of the categories to be removed
    catids_remove = ann.getCatIds(catNms=self.rcats)
    # Gives you a list of ids of annotations that contain those categories
    annids_remove = ann.getAnnIds(catIds=catids_remove)

    # Get keep category ids
    catids_keep = list(set(ann.getCatIds()) - set(catids_remove))
    # Get keep annotation ids
    annids_keep = list(set(ann.getAnnIds()) - set(annids_remove))

    with open(self.ann_dir / json_name) as it:
        x = json.load(it)

    del x[&#34;categories&#34;]
    x[&#34;categories&#34;] = ann.loadCats(catids_keep)
    del x[&#34;annotations&#34;]
    x[&#34;annotations&#34;] = ann.loadAnns(annids_keep)

    if remove_empty_frames:
        image_ids = []
        image_file_names = []
        for annotation in x[&#34;annotations&#34;]:
            image_ids.append(annotation[&#34;image_id&#34;])
        image_ids = list(set(image_ids))
        remove_image_ids = ann.getImgIds(catIds=catids_remove)
        all_image_ids = ann.getImgIds()
        
        del x[&#34;images&#34;]
        x[&#34;images&#34;] = ann.loadImgs(list(set(image_ids).union(set(all_image_ids) - set(remove_image_ids))))

        for image in x[&#34;images&#34;]:
            image_file_names.append(image[&#34;file_name&#34;])
        
        # img_folder = json_name
        all_image_names = os.listdir(img_folder)
        for single_image_name in all_image_names:
            if single_image_name not in image_file_names:
                os.remove(img_folder / Path(single_image_name))
    

    with open(resrm_dir / json_name, &#34;w&#34;) as oa:
        json.dump(x, oa)</code></pre>
</details>
</dd>
<dt id="data_handling.coco_assistant.coco_assistant.COCO_Assistant.visualise"><code class="name flex">
<span>def <span class="ident">visualise</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for visualising annotations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualise(self):
    &#34;&#34;&#34;
    Function for visualising annotations.
    &#34;&#34;&#34;
    print(&#34;Choose directory index (1:first, 2: second ..):&#34;)
    print([s.stem for s in self.imgfolders])

    dir_choice = input()
    try:
        dir_choice = int(dir_choice) - 1
    except ValueError:
        sys.exit(&#34;Please specify an index&#34;)

    if dir_choice &gt; len(self.imgfolders):
        raise AssertionError(&#34;Index exceeds number of datasets&#34;)
    ann = self.annfiles[dir_choice]
    img_dir = self.imgfolders[dir_choice]
    cocovis.visualise_all(ann, img_dir)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="data_handling.coco_assistant" href="index.html">data_handling.coco_assistant</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="data_handling.coco_assistant.coco_assistant.COCO_Assistant" href="#data_handling.coco_assistant.coco_assistant.COCO_Assistant">COCO_Assistant</a></code></h4>
<ul class="two-column">
<li><code><a title="data_handling.coco_assistant.coco_assistant.COCO_Assistant.anchors" href="#data_handling.coco_assistant.coco_assistant.COCO_Assistant.anchors">anchors</a></code></li>
<li><code><a title="data_handling.coco_assistant.coco_assistant.COCO_Assistant.ann_stats" href="#data_handling.coco_assistant.coco_assistant.COCO_Assistant.ann_stats">ann_stats</a></code></li>
<li><code><a title="data_handling.coco_assistant.coco_assistant.COCO_Assistant.category_subset" href="#data_handling.coco_assistant.coco_assistant.COCO_Assistant.category_subset">category_subset</a></code></li>
<li><code><a title="data_handling.coco_assistant.coco_assistant.COCO_Assistant.get_segmasks" href="#data_handling.coco_assistant.coco_assistant.COCO_Assistant.get_segmasks">get_segmasks</a></code></li>
<li><code><a title="data_handling.coco_assistant.coco_assistant.COCO_Assistant.merge" href="#data_handling.coco_assistant.coco_assistant.COCO_Assistant.merge">merge</a></code></li>
<li><code><a title="data_handling.coco_assistant.coco_assistant.COCO_Assistant.merge_same" href="#data_handling.coco_assistant.coco_assistant.COCO_Assistant.merge_same">merge_same</a></code></li>
<li><code><a title="data_handling.coco_assistant.coco_assistant.COCO_Assistant.remove_cat" href="#data_handling.coco_assistant.coco_assistant.COCO_Assistant.remove_cat">remove_cat</a></code></li>
<li><code><a title="data_handling.coco_assistant.coco_assistant.COCO_Assistant.visualise" href="#data_handling.coco_assistant.coco_assistant.COCO_Assistant.visualise">visualise</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>