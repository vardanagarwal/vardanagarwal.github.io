<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>seg_mask_modifs.mask_generator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>seg_mask_modifs.mask_generator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import cv2
import json
import numpy as np
import torch

from PIL import Image
from torchvision.transforms import transforms as transforms

from model_utils.model_celebmask import BiSeNet


class mask_generator:
    &#34;&#34;&#34; Class to generate masks using models&#34;&#34;&#34;

    def __init__(self, threshold=0.5, auto_init=True):
        &#34;&#34;&#34;
        Arguments:

            threshold: Minimum required model threshold on inferencing.
            auto_init: Auto initialize models whenever their label is seen.
            Initializes from default path model stored to in download_models(). If path changed then initialize manually.
        &#34;&#34;&#34;
        self.model_preference = [&#39;deeplabv3&#39;, &#39;maskrcnn&#39;, &#39;face&#39;]
        self.all_models = [&#39;deeplabv3&#39;, &#39;maskrcnn&#39;, &#39;face&#39;]
        self.maskrcnn_model = False
        self.deeplabv3_model = False
        self.face_model = False
        self.threshold = threshold
        self.auto_init = auto_init
        self.device = torch.device(&#39;cuda&#39;) if torch.cuda.is_available() else torch.device(&#39;cpu&#39;)
        self.gpu = torch.cuda.is_available()
        self.model_labels = json.load(open(&#39;model_utils/labels.json&#39;))

        self.label_mapping = {&#39;deeplabv3&#39;: &#39;deeplab_pascal_labels&#39;,
                              &#39;maskrcnn&#39;: &#39;maskrcnn_coco_labels&#39;,
                              &#39;face&#39;: &#39;face_labels&#39;}

    def init_maskrcnn(self, model_path=&#39;models/maskrcnn_resnet50_fpn.pt&#39;):
        &#34;&#34;&#34; Function to initialize maskrcnn model

        Arguments:

            model_path: Path to maskrcnn model
        &#34;&#34;&#34;
        self.maskrcnn_model = torch.load(model_path)
        self.maskrcnn_model.to(self.device).eval()

    def init_deeplabv3(self, model_path=&#39;models/deeplab_restnet101.pt&#39;):
        &#34;&#34;&#34; Function to initialize deeplabv3 model

        Arguments:

            model_path: Path to deeplabv3 model
        &#34;&#34;&#34;
        self.deeplabv3_model = torch.load(model_path)
        self.deeplabv3_model.to(self.device).eval()

    def init_face(self, model_path=&#39;models/face.pth&#39;):
        &#34;&#34;&#34; Function to initialize face model

        Arguments:

            model_path: Path to face model
        &#34;&#34;&#34;
        self.face_model = BiSeNet(n_classes=19)
        if self.gpu:
            self.face_model.cuda()
            self.face_model.load_state_dict(torch.load(model_path))
        else:
            self.face_model.load_state_dict(torch.load(model_path, map_location=&#39;cpu&#39;))
        self.face_model.eval()

    def print_model_preference(self):
        &#34;&#34;&#34; Function to know the current model preference&#34;&#34;&#34;
        print(self.model_preference)

    def set_model_preference(self, model=None, pos=0, model_list=None):
        &#34;&#34;&#34; Function to set the model preference.
        Only the models in model list will be used for mask generation.
        Pass either model along with its position or complete list containing models.
        If both are passed model_list will be preffered.

        Arguments:

            model: str having of &#39;deeplabv3&#39;, &#39;maskrcnn&#39;, &#39;face&#39; whose value need to be set.
            pos: int having the position of preference of the model starting from 0. Default: 0.
            model_list: List containing models
        &#34;&#34;&#34;

        if model_list is None and model is None:
            raise AttributeError(&#34;One of model or model_list needs to be passed&#34;)

        if model_list is not None:
            for models in model_list:
                if models not in self.all_models:
                    print(&#34;Wrong model name passed:&#34;, models)
                    raise ValueError
            self.model_preference = model_list
            return

        if model not in self.all_models:
            print(&#34;Wrong model name passed:&#34;, model)
            raise ValueError

        if model in self.model_preference:
            self.model_preference.remove(model)
        self.model_preference.insert(pos, model)

    def maskrcnn_inference(self, img, labels):
        &#34;&#34;&#34;Function to perform inference using MaskRCNN

        Arguments:

            img: input image
            labels: labels to generate mask of.

        Returns:

        output_mask: A combined mask of the labels provided&#34;&#34;&#34;

        transform = transforms.Compose([
            transforms.ToTensor()
        ])
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        img_rgb = transform(img_rgb)
        img_rgb = img_rgb.unsqueeze(0).to(self.device)

        with torch.no_grad():
            outputs = self.maskrcnn_model(img_rgb)

        # correct from code in docker
        scores = list(outputs[0][&#39;scores&#39;].detach().cpu().numpy())
        if len(outputs[0][&#39;masks&#39;]) == 1:
            masks = (outputs[0][&#39;masks&#39;] &gt; 0.5)[0].detach().cpu().numpy()
        else:
            masks = (outputs[0][&#39;masks&#39;] &gt; 0.5).squeeze().detach().cpu().numpy()
        pred_labels = [self.model_labels[&#39;maskrcnn_coco_labels&#39;][i] for i in outputs[0][&#39;labels&#39;]]
        output_mask = np.zeros((img.shape[:2]), dtype=np.uint8)

        for i in range(len(scores)):
            if scores[i] &gt; self.threshold and pred_labels[i] in labels:
                output_mask = cv2.bitwise_or(output_mask, np.array(masks[i], dtype=np.uint8))

        return output_mask

    def deeplabv3_inference(self, img, labels):
        &#34;&#34;&#34;Function to perform inference using deeplabv3

        Arguments:

            img: input image
            labels: labels to generate mask of.

        Returns:

            output_mask: A combined mask of the labels provided&#34;&#34;&#34;
        trf = transforms.Compose([transforms.ToTensor(),
                                  transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                                       std=[0.229, 0.224, 0.225])
                                  ])
        img_pil = Image.fromarray(img)
        inp = trf(img_pil).unsqueeze(0).to(self.device)
        with torch.no_grad():
            out = self.deeplabv3_model(inp)[&#39;out&#39;]
        output_mask = torch.argmax(out.squeeze(), dim=0).detach().cpu().numpy()
        pred_labels_ind = np.unique(output_mask)
        req_label_ind = [self.model_labels[&#39;deeplab_pascal_labels&#39;].index(
            label) for label in labels]

        for pred_label_ind in pred_labels_ind:
            if pred_label_ind not in req_label_ind:
                # converting all unwanted labels to 0
                output_mask[output_mask[:] == pred_label_ind] = 0

        output_mask = np.array(output_mask, dtype=np.uint8)
        _, output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
        return output_mask

    def face_inference(self, img, labels):
        &#34;&#34;&#34;Function to perform inference using face model

        Arguments:

            img: input image
            labels: labels to generate mask of.

        Returns:

            output_mask: A combined mask of the labels provided&#34;&#34;&#34;

        transform = transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)),
        ])
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        img_rgb = transform(img_rgb)
        img_rgb = img_rgb.unsqueeze(0).to(self.device)
        with torch.no_grad():
            out = self.face_model(img_rgb)[0]
        output_mask = out.squeeze(0).cpu().numpy().argmax(0)
        output_mask = output_mask.astype(np.uint8)
        pred_labels_ind = np.unique(output_mask)
        req_label_ind = [self.model_labels[&#39;face_labels&#39;].index(label) for label in labels]
        if &#34;face&#34; in labels:
            # for complete face blurring adding all label indices except hat and cloth
            # and removing its index from list
            req_label_ind.extend([i for i in range(16)])
            req_label_ind.append(17)
            req_label_ind.remove(19)
            req_label_ind = list(set(req_label_ind))

        for pred_label_ind in pred_labels_ind:
            if pred_label_ind not in req_label_ind:
                # converting all unwanted labels to 0
                output_mask[output_mask[:] == pred_label_ind] = 0

        _, output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
        return output_mask

    def generate(self, img, labels, use_model=None):
        &#34;&#34;&#34; Function to generate masks for labels.

        Arguments:

            img: Input image read by OpenCV
            labels: list containing one or more labels whose masks needs to be generated.
            use_model:  One of deeplabv3, maskrcnn or face.
            If argument passed only that model will be used for mask creation.

        Returns: mask of those labels.
        &#34;&#34;&#34;

        if use_model is not None:
            if use_model not in self.all_models:
                print(&#34;use_model should be one of:&#34;, *self.all_models)
                raise ValueError

            model_labels = self.model_labels[self.label_mapping[use_model]]
            labels_skipped = list(set(labels) - set(model_labels))
            if not len(labels_skipped):
                print(&#34;Skipping labels:&#34;, *labels_skipped,
                      &#34;, not present in labels of model:&#34;, use_model)
            labels = list(set(labels).intersection(set(model_labels)))

            # initialize model if auto_init is True and model is not initialized yet.
            if self.auto_init and not eval(&#34;self.&#34; + use_model + &#34;_model&#34;):
                eval(&#34;self.init_&#34; + use_model)
            # using eval(&#34;self.__&#34; + use_model + &#34;_inference&#34;) to generate inference funtion
            output_mask = eval(&#34;self.&#34; + use_model + &#34;_inference&#34;)(img, labels)
            output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
            return output_mask

        output_mask = np.zeros((img.shape[:2]), dtype=np.uint8)
        for model in self.model_preference:
            model_labels = self.model_labels[self.label_mapping[model]]
            labels_pass = list(set(labels).intersection(set(model_labels)))
            if len(labels_pass):
                # initialize model if auto_init is True and model is not initialized yet.
                if self.auto_init and not eval(&#34;self.&#34; + model + &#34;_model&#34;):
                    eval(&#34;self.init_&#34; + model)()
                print(&#34;Inferencing labels:&#34;, *labels_pass, &#34;with model:&#34;, model)
                mask = eval(&#34;self.&#34; + model + &#34;_inference&#34;)(img, labels_pass)
                labels = list(set(labels) - set(labels_pass))
                output_mask = cv2.bitwise_or(output_mask, mask)

        if len(labels):
            print(&#34;Labels skipped:&#34;, *labels, &#34;, not present in labels of any model&#34;)
        _, output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
        return output_mask


# Testing
if __name__ == &#34;__main__&#34;:
    obj = mask_generator()
    img = cv2.imread(&#39;images/city.jpg&#39;)
    mask = obj.generate(img, [&#34;backpack&#34;, &#34;suitcase&#34;])
    # print(mask)
    mask = cv2.bitwise_and(img, img, mask=mask)
    cv2.imshow(&#39;mask&#39;, mask)
    cv2.waitKey(0)
    cv2.destroyAllWindows()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="seg_mask_modifs.mask_generator.mask_generator"><code class="flex name class">
<span>class <span class="ident">mask_generator</span></span>
<span>(</span><span>threshold=0.5, auto_init=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to generate masks using models</p>
<h2 id="arguments">Arguments</h2>
<p>threshold: Minimum required model threshold on inferencing. <br>
auto_init: Auto initialize models whenever their label is seen. <br>
Initializes from default path model stored to in download_models(). If path changed then initialize manually.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mask_generator:
    &#34;&#34;&#34; Class to generate masks using models&#34;&#34;&#34;

    def __init__(self, threshold=0.5, auto_init=True):
        &#34;&#34;&#34;
        Arguments:

            threshold: Minimum required model threshold on inferencing.
            auto_init: Auto initialize models whenever their label is seen.
            Initializes from default path model stored to in download_models(). If path changed then initialize manually.
        &#34;&#34;&#34;
        self.model_preference = [&#39;deeplabv3&#39;, &#39;maskrcnn&#39;, &#39;face&#39;]
        self.all_models = [&#39;deeplabv3&#39;, &#39;maskrcnn&#39;, &#39;face&#39;]
        self.maskrcnn_model = False
        self.deeplabv3_model = False
        self.face_model = False
        self.threshold = threshold
        self.auto_init = auto_init
        self.device = torch.device(&#39;cuda&#39;) if torch.cuda.is_available() else torch.device(&#39;cpu&#39;)
        self.gpu = torch.cuda.is_available()
        self.model_labels = json.load(open(&#39;model_utils/labels.json&#39;))

        self.label_mapping = {&#39;deeplabv3&#39;: &#39;deeplab_pascal_labels&#39;,
                              &#39;maskrcnn&#39;: &#39;maskrcnn_coco_labels&#39;,
                              &#39;face&#39;: &#39;face_labels&#39;}

    def init_maskrcnn(self, model_path=&#39;models/maskrcnn_resnet50_fpn.pt&#39;):
        &#34;&#34;&#34; Function to initialize maskrcnn model

        Arguments:

            model_path: Path to maskrcnn model
        &#34;&#34;&#34;
        self.maskrcnn_model = torch.load(model_path)
        self.maskrcnn_model.to(self.device).eval()

    def init_deeplabv3(self, model_path=&#39;models/deeplab_restnet101.pt&#39;):
        &#34;&#34;&#34; Function to initialize deeplabv3 model

        Arguments:

            model_path: Path to deeplabv3 model
        &#34;&#34;&#34;
        self.deeplabv3_model = torch.load(model_path)
        self.deeplabv3_model.to(self.device).eval()

    def init_face(self, model_path=&#39;models/face.pth&#39;):
        &#34;&#34;&#34; Function to initialize face model

        Arguments:

            model_path: Path to face model
        &#34;&#34;&#34;
        self.face_model = BiSeNet(n_classes=19)
        if self.gpu:
            self.face_model.cuda()
            self.face_model.load_state_dict(torch.load(model_path))
        else:
            self.face_model.load_state_dict(torch.load(model_path, map_location=&#39;cpu&#39;))
        self.face_model.eval()

    def print_model_preference(self):
        &#34;&#34;&#34; Function to know the current model preference&#34;&#34;&#34;
        print(self.model_preference)

    def set_model_preference(self, model=None, pos=0, model_list=None):
        &#34;&#34;&#34; Function to set the model preference.
        Only the models in model list will be used for mask generation.
        Pass either model along with its position or complete list containing models.
        If both are passed model_list will be preffered.

        Arguments:

            model: str having of &#39;deeplabv3&#39;, &#39;maskrcnn&#39;, &#39;face&#39; whose value need to be set.
            pos: int having the position of preference of the model starting from 0. Default: 0.
            model_list: List containing models
        &#34;&#34;&#34;

        if model_list is None and model is None:
            raise AttributeError(&#34;One of model or model_list needs to be passed&#34;)

        if model_list is not None:
            for models in model_list:
                if models not in self.all_models:
                    print(&#34;Wrong model name passed:&#34;, models)
                    raise ValueError
            self.model_preference = model_list
            return

        if model not in self.all_models:
            print(&#34;Wrong model name passed:&#34;, model)
            raise ValueError

        if model in self.model_preference:
            self.model_preference.remove(model)
        self.model_preference.insert(pos, model)

    def maskrcnn_inference(self, img, labels):
        &#34;&#34;&#34;Function to perform inference using MaskRCNN

        Arguments:

            img: input image
            labels: labels to generate mask of.

        Returns:

        output_mask: A combined mask of the labels provided&#34;&#34;&#34;

        transform = transforms.Compose([
            transforms.ToTensor()
        ])
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        img_rgb = transform(img_rgb)
        img_rgb = img_rgb.unsqueeze(0).to(self.device)

        with torch.no_grad():
            outputs = self.maskrcnn_model(img_rgb)

        # correct from code in docker
        scores = list(outputs[0][&#39;scores&#39;].detach().cpu().numpy())
        if len(outputs[0][&#39;masks&#39;]) == 1:
            masks = (outputs[0][&#39;masks&#39;] &gt; 0.5)[0].detach().cpu().numpy()
        else:
            masks = (outputs[0][&#39;masks&#39;] &gt; 0.5).squeeze().detach().cpu().numpy()
        pred_labels = [self.model_labels[&#39;maskrcnn_coco_labels&#39;][i] for i in outputs[0][&#39;labels&#39;]]
        output_mask = np.zeros((img.shape[:2]), dtype=np.uint8)

        for i in range(len(scores)):
            if scores[i] &gt; self.threshold and pred_labels[i] in labels:
                output_mask = cv2.bitwise_or(output_mask, np.array(masks[i], dtype=np.uint8))

        return output_mask

    def deeplabv3_inference(self, img, labels):
        &#34;&#34;&#34;Function to perform inference using deeplabv3

        Arguments:

            img: input image
            labels: labels to generate mask of.

        Returns:

            output_mask: A combined mask of the labels provided&#34;&#34;&#34;
        trf = transforms.Compose([transforms.ToTensor(),
                                  transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                                       std=[0.229, 0.224, 0.225])
                                  ])
        img_pil = Image.fromarray(img)
        inp = trf(img_pil).unsqueeze(0).to(self.device)
        with torch.no_grad():
            out = self.deeplabv3_model(inp)[&#39;out&#39;]
        output_mask = torch.argmax(out.squeeze(), dim=0).detach().cpu().numpy()
        pred_labels_ind = np.unique(output_mask)
        req_label_ind = [self.model_labels[&#39;deeplab_pascal_labels&#39;].index(
            label) for label in labels]

        for pred_label_ind in pred_labels_ind:
            if pred_label_ind not in req_label_ind:
                # converting all unwanted labels to 0
                output_mask[output_mask[:] == pred_label_ind] = 0

        output_mask = np.array(output_mask, dtype=np.uint8)
        _, output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
        return output_mask

    def face_inference(self, img, labels):
        &#34;&#34;&#34;Function to perform inference using face model

        Arguments:

            img: input image
            labels: labels to generate mask of.

        Returns:

            output_mask: A combined mask of the labels provided&#34;&#34;&#34;

        transform = transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)),
        ])
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        img_rgb = transform(img_rgb)
        img_rgb = img_rgb.unsqueeze(0).to(self.device)
        with torch.no_grad():
            out = self.face_model(img_rgb)[0]
        output_mask = out.squeeze(0).cpu().numpy().argmax(0)
        output_mask = output_mask.astype(np.uint8)
        pred_labels_ind = np.unique(output_mask)
        req_label_ind = [self.model_labels[&#39;face_labels&#39;].index(label) for label in labels]
        if &#34;face&#34; in labels:
            # for complete face blurring adding all label indices except hat and cloth
            # and removing its index from list
            req_label_ind.extend([i for i in range(16)])
            req_label_ind.append(17)
            req_label_ind.remove(19)
            req_label_ind = list(set(req_label_ind))

        for pred_label_ind in pred_labels_ind:
            if pred_label_ind not in req_label_ind:
                # converting all unwanted labels to 0
                output_mask[output_mask[:] == pred_label_ind] = 0

        _, output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
        return output_mask

    def generate(self, img, labels, use_model=None):
        &#34;&#34;&#34; Function to generate masks for labels.

        Arguments:

            img: Input image read by OpenCV
            labels: list containing one or more labels whose masks needs to be generated.
            use_model:  One of deeplabv3, maskrcnn or face.
            If argument passed only that model will be used for mask creation.

        Returns: mask of those labels.
        &#34;&#34;&#34;

        if use_model is not None:
            if use_model not in self.all_models:
                print(&#34;use_model should be one of:&#34;, *self.all_models)
                raise ValueError

            model_labels = self.model_labels[self.label_mapping[use_model]]
            labels_skipped = list(set(labels) - set(model_labels))
            if not len(labels_skipped):
                print(&#34;Skipping labels:&#34;, *labels_skipped,
                      &#34;, not present in labels of model:&#34;, use_model)
            labels = list(set(labels).intersection(set(model_labels)))

            # initialize model if auto_init is True and model is not initialized yet.
            if self.auto_init and not eval(&#34;self.&#34; + use_model + &#34;_model&#34;):
                eval(&#34;self.init_&#34; + use_model)
            # using eval(&#34;self.__&#34; + use_model + &#34;_inference&#34;) to generate inference funtion
            output_mask = eval(&#34;self.&#34; + use_model + &#34;_inference&#34;)(img, labels)
            output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
            return output_mask

        output_mask = np.zeros((img.shape[:2]), dtype=np.uint8)
        for model in self.model_preference:
            model_labels = self.model_labels[self.label_mapping[model]]
            labels_pass = list(set(labels).intersection(set(model_labels)))
            if len(labels_pass):
                # initialize model if auto_init is True and model is not initialized yet.
                if self.auto_init and not eval(&#34;self.&#34; + model + &#34;_model&#34;):
                    eval(&#34;self.init_&#34; + model)()
                print(&#34;Inferencing labels:&#34;, *labels_pass, &#34;with model:&#34;, model)
                mask = eval(&#34;self.&#34; + model + &#34;_inference&#34;)(img, labels_pass)
                labels = list(set(labels) - set(labels_pass))
                output_mask = cv2.bitwise_or(output_mask, mask)

        if len(labels):
            print(&#34;Labels skipped:&#34;, *labels, &#34;, not present in labels of any model&#34;)
        _, output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
        return output_mask</code></pre>
</details>
<h3>Methods</h3>
<!-- <dl>
<dt id="seg_mask_modifs.mask_generator.mask_generator.deeplabv3_inference"><code class="name flex">
<span>def <span class="ident">deeplabv3_inference</span></span>(<span>self, img, labels)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to perform inference using deeplabv3</p>
<h2 id="arguments">Arguments</h2>
<p>img: input image
labels: labels to generate mask of.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>output_mask</code></dt>
<dd>A combined mask of the labels provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deeplabv3_inference(self, img, labels):
    &#34;&#34;&#34;Function to perform inference using deeplabv3

    Arguments:

        img: input image
        labels: labels to generate mask of.

    Returns:

        output_mask: A combined mask of the labels provided&#34;&#34;&#34;
    trf = transforms.Compose([transforms.ToTensor(),
                              transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                                   std=[0.229, 0.224, 0.225])
                              ])
    img_pil = Image.fromarray(img)
    inp = trf(img_pil).unsqueeze(0).to(self.device)
    with torch.no_grad():
        out = self.deeplabv3_model(inp)[&#39;out&#39;]
    output_mask = torch.argmax(out.squeeze(), dim=0).detach().cpu().numpy()
    pred_labels_ind = np.unique(output_mask)
    req_label_ind = [self.model_labels[&#39;deeplab_pascal_labels&#39;].index(
        label) for label in labels]

    for pred_label_ind in pred_labels_ind:
        if pred_label_ind not in req_label_ind:
            # converting all unwanted labels to 0
            output_mask[output_mask[:] == pred_label_ind] = 0

    output_mask = np.array(output_mask, dtype=np.uint8)
    _, output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
    return output_mask</code></pre>
</details> -->
<!-- </dd>
<dt id="seg_mask_modifs.mask_generator.mask_generator.face_inference"><code class="name flex">
<span>def <span class="ident">face_inference</span></span>(<span>self, img, labels)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to perform inference using face model</p>
<h2 id="arguments">Arguments</h2>
<p>img: input image
labels: labels to generate mask of.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>output_mask</code></dt>
<dd>A combined mask of the labels provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_inference(self, img, labels):
    &#34;&#34;&#34;Function to perform inference using face model

    Arguments:

        img: input image
        labels: labels to generate mask of.

    Returns:

        output_mask: A combined mask of the labels provided&#34;&#34;&#34;

    transform = transforms.Compose([
        transforms.ToTensor(),
        transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)),
    ])
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img_rgb = transform(img_rgb)
    img_rgb = img_rgb.unsqueeze(0).to(self.device)
    with torch.no_grad():
        out = self.face_model(img_rgb)[0]
    output_mask = out.squeeze(0).cpu().numpy().argmax(0)
    output_mask = output_mask.astype(np.uint8)
    pred_labels_ind = np.unique(output_mask)
    req_label_ind = [self.model_labels[&#39;face_labels&#39;].index(label) for label in labels]
    if &#34;face&#34; in labels:
        # for complete face blurring adding all label indices except hat and cloth
        # and removing its index from list
        req_label_ind.extend([i for i in range(16)])
        req_label_ind.append(17)
        req_label_ind.remove(19)
        req_label_ind = list(set(req_label_ind))

    for pred_label_ind in pred_labels_ind:
        if pred_label_ind not in req_label_ind:
            # converting all unwanted labels to 0
            output_mask[output_mask[:] == pred_label_ind] = 0

    _, output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
    return output_mask</code></pre>
</details>
</dd> -->
<dt id="seg_mask_modifs.mask_generator.mask_generator.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, img, labels, use_model=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to generate masks for labels.</p>
<h2 id="arguments">Arguments</h2>
<p>img: Input image read by OpenCV <br>
labels: list containing one or more labels whose masks needs to be generated. <br>
use_model:
One of deeplabv3, maskrcnn or face.
If argument passed only that model will be used for mask creation.</p>
<p>Returns: mask of those labels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(self, img, labels, use_model=None):
    &#34;&#34;&#34; Function to generate masks for labels.

    Arguments:

        img: Input image read by OpenCV
        labels: list containing one or more labels whose masks needs to be generated.
        use_model:  One of deeplabv3, maskrcnn or face.
        If argument passed only that model will be used for mask creation.

    Returns: mask of those labels.
    &#34;&#34;&#34;

    if use_model is not None:
        if use_model not in self.all_models:
            print(&#34;use_model should be one of:&#34;, *self.all_models)
            raise ValueError

        model_labels = self.model_labels[self.label_mapping[use_model]]
        labels_skipped = list(set(labels) - set(model_labels))
        if not len(labels_skipped):
            print(&#34;Skipping labels:&#34;, *labels_skipped,
                  &#34;, not present in labels of model:&#34;, use_model)
        labels = list(set(labels).intersection(set(model_labels)))

        # initialize model if auto_init is True and model is not initialized yet.
        if self.auto_init and not eval(&#34;self.&#34; + use_model + &#34;_model&#34;):
            eval(&#34;self.init_&#34; + use_model)
        # using eval(&#34;self.__&#34; + use_model + &#34;_inference&#34;) to generate inference funtion
        output_mask = eval(&#34;self.&#34; + use_model + &#34;_inference&#34;)(img, labels)
        output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
        return output_mask

    output_mask = np.zeros((img.shape[:2]), dtype=np.uint8)
    for model in self.model_preference:
        model_labels = self.model_labels[self.label_mapping[model]]
        labels_pass = list(set(labels).intersection(set(model_labels)))
        if len(labels_pass):
            # initialize model if auto_init is True and model is not initialized yet.
            if self.auto_init and not eval(&#34;self.&#34; + model + &#34;_model&#34;):
                eval(&#34;self.init_&#34; + model)()
            print(&#34;Inferencing labels:&#34;, *labels_pass, &#34;with model:&#34;, model)
            mask = eval(&#34;self.&#34; + model + &#34;_inference&#34;)(img, labels_pass)
            labels = list(set(labels) - set(labels_pass))
            output_mask = cv2.bitwise_or(output_mask, mask)

    if len(labels):
        print(&#34;Labels skipped:&#34;, *labels, &#34;, not present in labels of any model&#34;)
    _, output_mask = cv2.threshold(output_mask, 0, 255, cv2.THRESH_BINARY)
    return output_mask</code></pre>
</details>
</dd>
<dt id="seg_mask_modifs.mask_generator.mask_generator.init_deeplabv3"><code class="name flex">
<span>def <span class="ident">init_deeplabv3</span></span>(<span>self, model_path='models/deeplab_restnet101.pt')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to initialize deeplabv3 model</p>
<h2 id="arguments">Arguments</h2>
<p>model_path: Path to deeplabv3 model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_deeplabv3(self, model_path=&#39;models/deeplab_restnet101.pt&#39;):
    &#34;&#34;&#34; Function to initialize deeplabv3 model

    Arguments:

        model_path: Path to deeplabv3 model
    &#34;&#34;&#34;
    self.deeplabv3_model = torch.load(model_path)
    self.deeplabv3_model.to(self.device).eval()</code></pre>
</details>
</dd>
<dt id="seg_mask_modifs.mask_generator.mask_generator.init_face"><code class="name flex">
<span>def <span class="ident">init_face</span></span>(<span>self, model_path='models/face.pth')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to initialize face model</p>
<h2 id="arguments">Arguments</h2>
<p>model_path: Path to face model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_face(self, model_path=&#39;models/face.pth&#39;):
    &#34;&#34;&#34; Function to initialize face model

    Arguments:

        model_path: Path to face model
    &#34;&#34;&#34;
    self.face_model = BiSeNet(n_classes=19)
    if self.gpu:
        self.face_model.cuda()
        self.face_model.load_state_dict(torch.load(model_path))
    else:
        self.face_model.load_state_dict(torch.load(model_path, map_location=&#39;cpu&#39;))
    self.face_model.eval()</code></pre>
</details>
</dd>
<dt id="seg_mask_modifs.mask_generator.mask_generator.init_maskrcnn"><code class="name flex">
<span>def <span class="ident">init_maskrcnn</span></span>(<span>self, model_path='models/maskrcnn_resnet50_fpn.pt')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to initialize maskrcnn model</p>
<h2 id="arguments">Arguments</h2>
<p>model_path: Path to maskrcnn model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_maskrcnn(self, model_path=&#39;models/maskrcnn_resnet50_fpn.pt&#39;):
    &#34;&#34;&#34; Function to initialize maskrcnn model

    Arguments:

        model_path: Path to maskrcnn model
    &#34;&#34;&#34;
    self.maskrcnn_model = torch.load(model_path)
    self.maskrcnn_model.to(self.device).eval()</code></pre>
</details>
</dd>
<!-- <dt id="seg_mask_modifs.mask_generator.mask_generator.maskrcnn_inference"><code class="name flex">
<span>def <span class="ident">maskrcnn_inference</span></span>(<span>self, img, labels)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to perform inference using MaskRCNN</p>
<h2 id="arguments">Arguments</h2>
<p>img: input image
labels: labels to generate mask of.</p>
<p>Returns:</p>
<p>output_mask: A combined mask of the labels provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maskrcnn_inference(self, img, labels):
    &#34;&#34;&#34;Function to perform inference using MaskRCNN

    Arguments:

        img: input image
        labels: labels to generate mask of.

    Returns:

    output_mask: A combined mask of the labels provided&#34;&#34;&#34;

    transform = transforms.Compose([
        transforms.ToTensor()
    ])
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img_rgb = transform(img_rgb)
    img_rgb = img_rgb.unsqueeze(0).to(self.device)

    with torch.no_grad():
        outputs = self.maskrcnn_model(img_rgb)

    # correct from code in docker
    scores = list(outputs[0][&#39;scores&#39;].detach().cpu().numpy())
    if len(outputs[0][&#39;masks&#39;]) == 1:
        masks = (outputs[0][&#39;masks&#39;] &gt; 0.5)[0].detach().cpu().numpy()
    else:
        masks = (outputs[0][&#39;masks&#39;] &gt; 0.5).squeeze().detach().cpu().numpy()
    pred_labels = [self.model_labels[&#39;maskrcnn_coco_labels&#39;][i] for i in outputs[0][&#39;labels&#39;]]
    output_mask = np.zeros((img.shape[:2]), dtype=np.uint8)

    for i in range(len(scores)):
        if scores[i] &gt; self.threshold and pred_labels[i] in labels:
            output_mask = cv2.bitwise_or(output_mask, np.array(masks[i], dtype=np.uint8))

    return output_mask</code></pre>
</details>
</dd> -->
<dt id="seg_mask_modifs.mask_generator.mask_generator.print_model_preference"><code class="name flex">
<span>def <span class="ident">print_model_preference</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to know the current model preference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_model_preference(self):
    &#34;&#34;&#34; Function to know the current model preference&#34;&#34;&#34;
    print(self.model_preference)</code></pre>
</details>
</dd>
<dt id="seg_mask_modifs.mask_generator.mask_generator.set_model_preference"><code class="name flex">
<span>def <span class="ident">set_model_preference</span></span>(<span>self, model=None, pos=0, model_list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to set the model preference.
Only the models in model list will be used for mask generation.
Pass either model along with its position or complete list containing models.
If both are passed model_list will be preffered.</p>
<h2 id="arguments">Arguments</h2>
<p>model: str having of 'deeplabv3', 'maskrcnn', 'face' whose value need to be set. <br>
pos: int having the position of preference of the model starting from 0. Default: 0. <br>
model_list: List containing models</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_model_preference(self, model=None, pos=0, model_list=None):
    &#34;&#34;&#34; Function to set the model preference.
    Only the models in model list will be used for mask generation.
    Pass either model along with its position or complete list containing models.
    If both are passed model_list will be preffered.

    Arguments:

        model: str having of &#39;deeplabv3&#39;, &#39;maskrcnn&#39;, &#39;face&#39; whose value need to be set.
        pos: int having the position of preference of the model starting from 0. Default: 0.
        model_list: List containing models
    &#34;&#34;&#34;

    if model_list is None and model is None:
        raise AttributeError(&#34;One of model or model_list needs to be passed&#34;)

    if model_list is not None:
        for models in model_list:
            if models not in self.all_models:
                print(&#34;Wrong model name passed:&#34;, models)
                raise ValueError
        self.model_preference = model_list
        return

    if model not in self.all_models:
        print(&#34;Wrong model name passed:&#34;, model)
        raise ValueError

    if model in self.model_preference:
        self.model_preference.remove(model)
    self.model_preference.insert(pos, model)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="seg_mask_modifs" href="../seg_mask_modifs.html">seg_mask_modifs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="seg_mask_modifs.mask_generator.mask_generator" href="#seg_mask_modifs.mask_generator.mask_generator">mask_generator</a></code></h4>
<ul class="">
<!-- <li><code><a title="seg_mask_modifs.mask_generator.mask_generator.deeplabv3_inference" href="#seg_mask_modifs.mask_generator.mask_generator.deeplabv3_inference">deeplabv3_inference</a></code></li> -->
<!-- <li><code><a title="seg_mask_modifs.mask_generator.mask_generator.face_inference" href="#seg_mask_modifs.mask_generator.mask_generator.face_inference">face_inference</a></code></li> -->
<li><code><a title="seg_mask_modifs.mask_generator.mask_generator.generate" href="#seg_mask_modifs.mask_generator.mask_generator.generate">generate</a></code></li>
<li><code><a title="seg_mask_modifs.mask_generator.mask_generator.init_deeplabv3" href="#seg_mask_modifs.mask_generator.mask_generator.init_deeplabv3">init_deeplabv3</a></code></li>
<li><code><a title="seg_mask_modifs.mask_generator.mask_generator.init_face" href="#seg_mask_modifs.mask_generator.mask_generator.init_face">init_face</a></code></li>
<li><code><a title="seg_mask_modifs.mask_generator.mask_generator.init_maskrcnn" href="#seg_mask_modifs.mask_generator.mask_generator.init_maskrcnn">init_maskrcnn</a></code></li>
<!-- <li><code><a title="seg_mask_modifs.mask_generator.mask_generator.maskrcnn_inference" href="#seg_mask_modifs.mask_generator.mask_generator.maskrcnn_inference">maskrcnn_inference</a></code></li> -->
<li><code><a title="seg_mask_modifs.mask_generator.mask_generator.print_model_preference" href="#seg_mask_modifs.mask_generator.mask_generator.print_model_preference">print_model_preference</a></code></li>
<li><code><a title="seg_mask_modifs.mask_generator.mask_generator.set_model_preference" href="#seg_mask_modifs.mask_generator.mask_generator.set_model_preference">set_model_preference</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>